#include <sys/socket.h>
#include <sys/wait.h>
#include <netinet/in.h>
#include <cstdio>
#include <sys/types.h>
#include <unistd.h>
#include <cstring>
#include <netdb.h>
#include <iostream>
#include <fstream>
#include <iterator>
#include <algorithm>
#include <chrono>

using namespace std;




const int BUCKET_COUNT = 2000;
#define BUCKET_SIZE "50"

/*
 *
 * Generates BUCKET_SIZE flags and fires them BUCKET_COUNT times to localhost:31337.
 * No result checking is done, but total time and flags/second is calculated.
 * Flags are generated by calling scripts/generate_bucket.py
 *
 * USAGE: ./benchmark-oldflags [# of connections]
 *
 * In total, BUCKET_SIZE * BUCKET_COUNT * #connections flags are sent.
 *
 */





std::string readBuckets() {
	if (system("python3 ../scripts/generate_bucket.py " BUCKET_SIZE) < 0) perror("system()");
	std::ifstream t("bucket.txt");
	return std::string((std::istreambuf_iterator<char>(t)), std::istreambuf_iterator<char>());
}


long countLines(string &buckets) {
	return std::count(buckets.begin(), buckets.end(), '\n');
}


int send_singlethread(int sockfd, std::string& buckets){
	const char* buffer = buckets.c_str();
	size_t bufferLen = buckets.length();
	char tmp[4096];
	ssize_t rc;

	for (int i = 0; i < BUCKET_COUNT; i++){
		size_t n = 0;
		do{
			ssize_t count = write(sockfd, buffer+n, bufferLen - n);
			if (count <= 0){
				perror("Invalid count");
				return 2;
			}
			n += count;
		}while (n < bufferLen);

		// read some responses
		if (read(sockfd, tmp, sizeof tmp) < 0){
			perror("read");
			return 3;
		}
	}
	shutdown(sockfd, SHUT_WR);

	// read all responses
	while ((rc = read(sockfd, tmp, sizeof tmp)) > 0){}
	if (rc < 0) perror("read_all");

	return 0;
}


int do_forks(int process_count, long flagsPerBucket){
	cout << "Forking " << process_count << " times..." << endl;
	const int sleeptime = 100000;

	std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();

	for (int i = 0; i < process_count; i++){
		pid_t pid = fork();
		if (pid < 0){
			perror("fork()");
			return 1;
		}
		else if (pid == 0){
			// child - start working
			usleep(sleeptime);
			return -1;
		}
	}
	// Wait for childs
	int status;
	while (wait(&status) > 0){}

	std::chrono::steady_clock::time_point end= std::chrono::steady_clock::now();
	auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count() - sleeptime;

	cout << "All child processes terminated" << endl;
	printf("Wrote %ld flags (in buckets of %ld, by %d processes) in %.3f seconds\n", BUCKET_COUNT * flagsPerBucket * process_count, flagsPerBucket, process_count, duration/1000000.0);
	printf("= %.2f flags / second\n", BUCKET_COUNT * flagsPerBucket * process_count * 1000000.0 / duration);
	return 0;
}


int main(int argc, char* argv[]) {
	string buckets = readBuckets();
	long flagsPerBucket = countLines(buckets);

	if (argc > 1){
		int forkno = atoi(argv[1]);
		int r = do_forks(forkno, flagsPerBucket);
		if (r >= 0) return r;
	}

	int sockfd = socket(AF_INET, SOCK_STREAM, 0);
	struct sockaddr_in serv_addr;
	memset(&serv_addr, 0, sizeof serv_addr);

	struct hostent *server = gethostbyname("localhost");
	bzero((char *) &serv_addr, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	bcopy((char *) server->h_addr, (char *) &serv_addr.sin_addr.s_addr, server->h_length);
	serv_addr.sin_port = htons(31337);

	if (connect(sockfd, (struct sockaddr *) &serv_addr, sizeof serv_addr) < 0) {
		perror("Connect");
		return 1;
	}
	cout << "Connected..." << endl;

	std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();

	int r = send_singlethread(sockfd, buckets);
	if (r != 0) return r;

	std::chrono::steady_clock::time_point end= std::chrono::steady_clock::now();
	auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - begin).count();

	close(sockfd);
	cout << "All written." << endl;

	printf("Wrote %ld flags (in buckets of %ld) in %.3f seconds\n", BUCKET_COUNT * flagsPerBucket, flagsPerBucket, duration/1000000.0);
	printf("= %.2f flags / second\n", BUCKET_COUNT * flagsPerBucket * 1000000.0 / duration);

	return 0;
}
